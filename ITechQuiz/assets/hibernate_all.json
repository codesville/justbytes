{"QandAList":
	[
				{"category":"Hibernate","topic_id":"21","question":"What is ORM ?","answer":"ORM stands for object/relational mapping. ORM is the automated persistence of objects in a Java application to the tables in a relational database.Hibernate is a pure Java object-relational mapping (ORM) and persistence framework that allows you to map plain old Java objects to relational database tables using (XML) configuration files."},
				{"category":"Hibernate","topic_id":"21","question":"What are the Core interfaces are of Hibernate framework?","answer":"The five core interfaces are used in just about every Hibernate application. Using these interfaces, you can store and retrieve persistent objects and control transactions. Session interface,SessionFactory interface, Configuration interface, Transaction interface, Query and Criteria interfaces"},
				{"category":"Hibernate","topic_id":"21","question":"What are named queries?","answer":"Named queries are defined as regular queries with a named identifier in the mapping document using a CDATA section if it has any markup characters.It can then be retrieved from the session and executed.session.getNamedQuery('named_id')"},
				{"category":"Hibernate","topic_id":"21","question":"When is the session flushed?","answer":"Session will execute the SQL statements needed to synchronize the JDBC connection's state with the state of objects held in memory. This process, called flush, occurs by default at the following points:  before some query executions,  from org.hibernate.Transaction.commit(),  from Session.flush() "},
				{"category":"Hibernate","topic_id":"21","question":"How is transitive persistence achieved?","answer":"If you want an operation to be cascaded along an association, you must indicate that in the mapping document using cascade styles like create, merge, save-update, delete, lock, refresh, evict, replicate or all."},
				{"category":"Hibernate","topic_id":"21","question":"What role does the Session interface play in Hibernate?","answer":"The Session interface is the primary interface used by Hibernate applications. It is a single-threaded, short-lived object representing a conversation between the application and the persistent store. It allows you to create query objects to retrieve persistent objects.Session session = sessionFactory.openSession();"},
				{"category":"Hibernate","topic_id":"21","question":"What role does the SessionFactory interface play in Hibernate?","answer":"The application obtains Session instances from a SessionFactory. There is typically a single SessionFactory for the whole application created during application initialization. The SessionFactory caches generate SQL statements and other mapping metadata that Hibernate uses at runtime. It also holds cached data that has been read in one unit of work and may be reused in a future unit of work.SessionFactory sessionFactory = configuration.buildSessionFactory();"},
				{"category":"Hibernate","topic_id":"21","question":"What's the difference between load() and get()?","answer":"load() method will throw an exception if the unique id is not found in the database whereas get() method will return null if the unique id is not found in the database.load() just returns a proxy by default and database won't be hit until the proxy is first invoked whereas get() will hit the database immediately. "},
				{"category":"Hibernate","topic_id":"21","question":"What is the difference between and merge and update ?","answer":"Use update() if you are sure that the session does not contain an already persistent instance with the same identifier, and merge() if you want to merge your modifications at any time without consideration of the state of the session."},
				{"category":"Hibernate","topic_id":"21","question":"How do you define sequence generated primary key in hibernate?","answer":"Using <generator> tag."},
				{"category":"Hibernate","topic_id":"21","question":"What are the different generator algorithms?","answer":"Generators are used to generate unique identifiers for instances of the persistent class.increment:  generates identifiers of type long, short or int that are unique only when no other process is inserting data into the same table.identity:  supports identity columns in DB2, MySQL, MS SQL Server, Sybase and HypersonicSQL. The returned identifier is of type long, short or int.sequence:  uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator in Interbase. The returned identifier is of type long, short or int. hilo: uses a hi/lo algorithm to efficiently generate identifiers of type long, short or int, given a table and column (by default hibernate_unique_key and next_hi respectively) as a source of hi values. The hi/lo algorithm generates identifiers that are unique only for a particular database.uuid:  uses a 128-bit UUID algorithm to generate identifiers of type string that are unique within a network.guid:  uses a database-generated GUID string on MS SQL Server and MySQL.native: selects identity, sequence or hilo depending upon the capabilities of the underlying database.assigned: lets the application assign an identifier to the object before save() is called. This is the default strategy if no <generator> element is specified."},
				{"category":"Hibernate","topic_id":"21","question":"How is a discriminator used?","answer":"The <discriminator> element is required for polymorphic persistence using the table-per-class-hierarchy mapping strategy. It declares a discriminator column of the table."},
				{"category":"Hibernate","topic_id":"21","question":"What is HibernateTemplate?","answer":"HibernateTemplate is a helper class which provides different methods for querying/retrieving data from the database. It also converts checked HibernateExceptions into unchecked DataAccessExceptions."},
				{"category":"Hibernate","topic_id":"21","question":"How do you switch between relational databases without code changes?","answer":"Using Hibernate SQL Dialects , we can switch databases. Hibernate will generate appropriate hql queries based on the dialect defined."},
				{"category":"Hibernate","topic_id":"21","question":"What is automatic dirty checking?","answer":"Automatic dirty checking is a feature that saves us the effort of explicitly asking Hibernate to update the database when we modify the state of an object inside a transaction."},
				{"category":"Hibernate","topic_id":"21","question":"What are the Collection types in Hibernate ?","answer":"Bag, Set,List, Array,Map"},
				{"category":"Hibernate","topic_id":"21","question":"What is HQL?","answer":"HQL stands for Hibernate Query Language. Hibernate allows the user to express queries in its own portable SQL extension and this is called as HQL. It also allows the user to express in native SQL."},
				{"category":"Hibernate","topic_id":"21","question":"What is Criteria API?","answer":"Criteria is a simplified API for retrieving entities by composing Criterion objects. This is a very convenient approach for functionality like 'search' screens where there is a variable number of conditions to be placed upon the result set."},
				{"category":"Hibernate","topic_id":"21","question":"What are the ways to express joins in HQL?","answer":"HQL provides four ways of expressing (inner and outer) joins:- An implicit association join, An ordinary join in the FROM clause, A fetch join in the FROM clause. A theta-style join in the WHERE clause."},
				{"category":"Hibernate","topic_id":"21","question":"What is Hibernate proxy? ","answer":"The proxy attribute enables lazy initialization of persistent instances of the class. Hibernate will initially return CGLIB proxies which implement the named interface. The actual persistent object will be loaded when a method of the proxy is invoked."},
				{"category":"Hibernate","topic_id":"21","question":"What is transactional write-behind?","answer":"Hibernate uses a sophisticated algorithm to determine an efficient ordering that avoids database foreign key constraint violations but is still sufficiently predictable to the user. This feature is called transactional write-behind."},
				{"category":"Hibernate","topic_id":"21","question":"What are the types of Hibernate instance states ?","answer":"Transient -The instance is not associated with any persistence context. Persistent -The instance is associated with a persistence context. Detached -The instance was associated with a persistence context which has been closed and currently not associated"},
				{"category":"Hibernate","topic_id":"21","question":"What are the types of inheritance models in Hibernate?","answer":"Table per class hierarchy,Table per subclass, Table per concrete class"},
				{"category":"Hibernate","topic_id":"21","question":"Where should SessionFactory be placed so that it can be easily accessed?","answer":"If the SessionFactory is placed in JNDI then it can be easily accessed and shared between different threads and various components that are hibernate aware. You can set the SessionFactory to a JNDI by configuring a property hibernate.session_factory_name in the hibernate.properties file."},
				{"category":"Hibernate","topic_id":"21","question":"What are the benefits of detached objects?","answer":"Detached objects can be passed across layers all the way up to the presentation layer without having to use any DTOs (Data Transfer Objects). You can later on re-attach the detached objects to another session."},
				{"category":"Hibernate","topic_id":"21","question":"Can you share a session object between different threads?","answer":"To avoid creating too many sessions ThreadLocal class can be used to get the current session no matter how many times you make call to the currentSession() method."},
				{"category":"Hibernate","topic_id":"21","question":"How would you reattach detached objects to a session when the same object has already been loaded into the session?","answer":"session.merge()"},
				{"category":"Hibernate","topic_id":"21","question":"What are the general considerations or best practices for defining your Hibernate persistent classes?","answer":"1.You must have a default no-argument constructor for your persistent classes and there should be getXXX() (i.e accessor/getter) and setXXX( i.e. mutator/setter) methods for all your persistable instance variables.2.You should implement the equals() and hashCode() methods based on your business key and it is important not to use the id field in your equals() and hashCode() definition if the id field is a surrogate key (i.e. Hibernate managed identifier). This is because the Hibernate only generates and sets the field when saving the object.3. It is recommended to implement the Serializable interface. This is potentially useful if you want to migrate around a multi-processor cluster.4.The persistent class should not be final because if it is final then lazy loading cannot be used by creating proxy objects.5.Use XDoclet tags for generating your *.hbm.xml files or Annotations (JDK 1.5 onwards), which are less verbose than *.hbm.xml files. "},
				{"category":"Hibernate","topic_id":"21","question":"What is lazy fetching?","answer":"All child objects in a collection are fetched when the application invokes an operation upon that collection. This is the default for collections."},
				{"category":"Hibernate","topic_id":"21","question":"How does Hibernate distinguish between transient (i.e. newly instantiated) and detached objects?","answer":"    Hibernate uses the 'version' property, if there is one. If not uses the identifier value. No identifier value means a new object. This does work only for Hibernate managed surrogate keys. Does not work for natural keys and assigned (i.e. not managed by Hibernate) surrogate keys. Write your own strategy with Interceptor.isUnsaved( )."},
				{"category":"Hibernate","topic_id":"21","question":"What are the different fetch strategies?","answer":" Join fetching: Hibernate retrieves the associated instance or collection in the same SELECT, using an OUTER JOIN. Select fetching: a second SELECT is used to retrieve the associated entity or collection. Unless you explicitly disable lazy fetching by specifying lazy='false', this second select will only be executed when you access the association. Subselect fetching: a second SELECT is used to retrieve the associated collections for all entities retrieved in a previous query or fetch.Unless you explicitly disable lazy fetching by specifying lazy='false', this second select will only be executed when you access the association.Batch fetching: an optimization strategy for select fetching. Hibernate retrieves a batch of entity instances or collections in a single SELECT by specifying a list of primary or foreign keys. "},
				{"category":"Hibernate","topic_id":"21","question":"What are the different levels of caching?","answer":"First level cache is the Session which is a transaction-level cache of persistent data.Second level cache: Hibernate allows cluster or JVM-level (SessionFactory-level) cache on a class-by-class and collection-by-collection basis.Caches can be maintained in memory,disk or cluster.Eg:EhCache,OSCache,SwarmCache,TreeCache,JBossCache"},
				{"category":"Hibernate","topic_id":"21","question":"How can a persistent object be removed from a hibernate session?","answer":"session.evict() method can be used to remove the object and its collections from the first-level cache."},
				{"category":"Hibernate","topic_id":"21","question":"What is Query Cache?","answer":"Query result sets can also be cached. This is only useful for queries that are run frequently with the same parameters. To enable it: hibernate.cache.use_query_cache true "},
				{"category":"Hibernate","topic_id":"21","question":"How is Pagination achieved in Hibernate?","answer":"Set the bounds using the methods in Query object: q.setFirstResult(20);q.setMaxResults(10);"},
				{"category":"Hibernate","topic_id":"21","question":"What is the difference between optimistic vs pessimistic concurrency control?","answer":"Optimistic concurrency control is achieved with versioning. Version checking uses version numbers, or timestamps, to detect conflicting updates and to prevent lost updates.Pessimistic locking involves obtaining exclusive pessimistic locks or re-obtain locks at the start of a new transaction. "},
				{"category":"Hibernate","topic_id":"21","question":"How are transactions used in a non-managed environment?","answer":"Transaction tx = session.beginTransaction();.....tx.commit() or tx.rollback();"},
				{"category":"Hibernate","topic_id":"21","question":"What are the different LockModes?","answer":"LockMode.WRITE,READ,UPGRADE ,UPGRADE_NOWAIT"},
				{"category":"Hibernate","topic_id":"21","question":"What are the different FlushModes?","answer":"FlushMode.COMMIT:only flush at commit time when the Hibernate Transaction API is used.FlushMode.AUTO: flush automatically using the explained routine, or FlushMode.MANUAL: never flush unless flush() is called explicitly."},
				{"category":"Hibernate","topic_id":"21","question":"How is a bidirectional many-to-many association achieved?","answer":"By using a join table containing the keys from both the tables.Declare a collection(like <set>) in each of the table's mapping file pointing to the join table and declare the <many-to-many> id column on which to join."}
	]
}
