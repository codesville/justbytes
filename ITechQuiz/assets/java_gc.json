{"QandAList":
	[
				{"category":"Java","topic_id":"3","question":"What is Garbage Collection? ","answer":"Garbage collection is also called automatic memory management as JVM automatically removes the unused variables/objects from the memory. The name 'garbage collection' implies that objects that are no longer needed or used by the program are 'garbage' and can be thrown away to create free space for the programs that are currently running."},
				{"category":"Java","topic_id":"3","question":"Which part of the memory is involved in Garbage Collection? Stack or Heap?","answer":"Heap"},
				{"category":"Java","topic_id":"3","question":"What is the responsibility of Garbage Collector?","answer":"Garbage collector frees the memory occupied by the unreachable objects during the java program by deleting these unreachable objects.It ensures that the available memory will be used efficiently."},
				{"category":"Java","topic_id":"3","question":"Is garbage collector a daemon thread?","answer":"Yes GC is a daemon thread. A daemon thread runs behind the application. It is started by JVM. The thread stops when all non-daemon threads stop. "},
				{"category":"Java","topic_id":"3","question":"What is the purpose of overriding finalize() method?","answer":"The finalize() method should be overridden for an object to include the clean up code or to dispose of the system resources that should to be done before the object is garbage collected."},
				{"category":"Java","topic_id":"3","question":"How many times does the garbage collector calls the finalize() method for an object?","answer":"Only once."},
				{"category":"Java","topic_id":"3","question":"What happens if an uncaught exception is thrown from during the execution of the finalize() method of an object? ","answer":"The exception will be ignored and the garbage collection (finalization) of that object terminates."},
				{"category":"Java","topic_id":"3","question":"What are different ways to call garbage collector? ","answer":"Garbage collection can be invoked using System.gc() or Runtime.getRuntime().gc().However it is not guaranteed to run."},
				{"category":"Java","topic_id":"3","question":"What is the Perm Gen space?","answer":"Permanent Generation (non-heap): The pool containing all the reflective data of the virtual machine itself, such as class and method objects. With Java VMs that use class data sharing, this generation is divided into read-only and read-write areas.JVM settings used to set the size of PermGen space: -XX:PermSize=<value> (initial), -XX:MaxPermSize=<value> (max)"},
				{"category":"Java","topic_id":"3","question":"What are the different heap spaces?","answer":"Eden Space (heap): The pool from which memory is initially allocated for most objects. Survivor Space (heap): The pool containing objects that have survived the garbage collection of the Eden space. Tenured Generation (heap): The pool containing objects that have existed for some time in the survivor space."},
				{"category":"Java","topic_id":"3","question":"Who manages the heap space?","answer":"JVM does. However JNI managed memory is not controlled by the JVM."},
				{"category":"Java","topic_id":"3","question":"How is the size of the heap configured?","answer":"Using JVM args, -Xms for min size and -Xmx for max size. Eg: java -Xms256m -Xmx512m <classname>"},
				{"category":"Java","topic_id":"3","question":"What comprises the JVM process heap space?","answer":"It is the non-heap space allocated to Permanent Space,Code Generation,Socket Buffers,Thread Stacks,Direct Memory Space,JNI Code,Garbage Collection,JNI Allocated Memory"},
				{"category":"Java","topic_id":"3","question":"What is the Mark and Sweep algorithm?","answer":"Mark phase: Iterate through all objects and mark the 'unreachable' as garbage. Sweep phase: Remove all previously marked objects and reclaim memory. It takes a long time depending on the size of the heap.Known as the 'stop-the-world-gc' since the entire JVM is locked down. "},
				{"category":"Java","topic_id":"3","question":"What are some other GC strategies?","answer":"a)Incremental:Time GC with new object creation.If GC runs, suspend new allocation. b)Concurrent/Parallel: Allocation happens at the same time as GC.Very complex locking regimes.Generations/Spaces make it easier.-XX:+UseParNewGC c)CMS(Concurrent Mark and Sweep):-XX:+UseConcMarkSweepGC"},
				{"category":"Java","topic_id":"3","question":"How can you minimize the need of garbage collection and make the memory use more effective? ","answer":"By using object pooling and weak object references. We need to ensure that all objects that are no longer required in the program are cleared off using finalize() blocks in your code. "},
				{"category":"Java","topic_id":"3","question":"What are some of the JVM profilers?","answer":"JConsole, JHat"},
				{"category":"Java","topic_id":"3","question":"What are major GC related changes in Java 5?","answer":"The major enhancements are GC ergonomics.Platform-dependent default selections for the garbage collector, heap size, and runtime compiler were introduced to better match the needs of different types of applications while requiring less command-line tuning.The prior version's serial collector (-XX:+UseSerialGC) changed to a parallel collector (-XX:+UseParallelGC). You can override this default by using the -XX:+UseSerialGC command-line option to the java command. Enormous changes have made to the heap size.Before J2SE 5.0, the default initial heap size was a reasonable minimum, which varies by platform."},
				{"category":"Java","topic_id":"3","question":"What are major GC related changes in Java 6?","answer":"Parallel Compaction Collector is a feature that enables the Garbage Collector to do collections in parallel leading to less garbage collection overhead and increase the performance for applications which require lager heaps.Concurrent Low Pause Collector: Concurrent Mark Sweep Collector Enhancements CMS collector improved to provide concurrent collection for System.gc() and Runtime.getRuntime().gc() method instructions.In Java SE 6, these instructions terminated all the threads to collect entire heap which lead to long pause times in applications with high heaps. This latest improved collector keeps the pause times shorter as how much as possible at the time of entire heap collection. "},
				{"category":"Java","topic_id":"3","question":"What are major GC related changes in Java 7?","answer":"It is called G1, which is short for Garbage First. It replaces the regular Concurrent Mark and Sweep Garbage Collectors with increased performance.G1 is considered as 'server centric'.G1 uses parallelism which are mostly used in hardware today increasing the performance and speed in Garbage Collection. Concurrency feature of G1 allows to run Java threads to minimize the heap operations at stop pauses.Increasing the Garbage Collection is treating the young objects(newly created) and the old objects(which lived for some time) differently.G1 mainly focuses on young objects as they can be reclaimable when traversing the old objects.Heap compaction is done to eliminate fragmentation problems.G1 can be more predictable when compared to CMS.A single contiguous heap which is split into same-sized regions. No separation between younger and older regions.G1 uses evacuation pauses which are done in parallel by using all the available processors.G1 uses a pause prediction model to meet user-defined pause time targets. Like CMS,G1 also periodically performs a concurrent marking phase but doesn't perform a sweeping phase."}
	]
}