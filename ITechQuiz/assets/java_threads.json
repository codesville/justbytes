{"QandAList":
	[
				{"category":"Java","topic_id":"10","question":"What is a Thread?","answer":"A thread of execution is an individual process (a \"lightweight\" process) that has its own call stack. "},
				{"category":"Java","topic_id":"10","question":"What is difference between thread and process? ","answer":"Threads share the address space of the process that  created it; processes have their own address. 2. Threads have direct access to the data segment of its process; processes have their own copy of the data segment of the parent process.3. Threads can directly communicate with other threads of its process; processes must use interprocess communication to communicate with sibling processes.4. Threads have almost no overhead; processes have considerable overhead.5. New threads are easily created; new processes require duplication of the parent process.6. Threads can exercise considerable control over threads of the same process; processes can only exercise control over child processes.7. Changes to the main thread (cancellation, priority change, etc.) may affect the behavior of the other threads of the process; changes to the parent process do not affect child processes."},
				{"category":"Java","topic_id":"10","question":"What are the two ways of creating thread?","answer":"There are two ways to create a new thread.1)Extend the Thread class and override the run() method in your class. Create an instance of the subclass and invoke the start() method on it, which will create a new thread of execution.Implements the Runnable interface.The class will have to implement the run() method in the Runnable interface. Create an instance of this class. Pass the reference of this instance to the Thread constructor a new thread of execution will be created."},
				{"category":"Java","topic_id":"10","question":"What are the different states of a thread's lifecycle?","answer":"1)New - When a thread is instantiated it is in New state until the start() method is called on the thread instance. In this state the thread is not considered to be alive.2) Runnable - The thread enters into this state after the start method is called in the thread instance. The thread may enter into the Runnable state from Running state. In this state the thread is considered to be alive.3) Running - When the thread scheduler picks up the thread from the Runnable thread's pool, the thread starts running and the thread is said to be in Running state. 4) Waiting/Blocked/Sleeping - In these states the thread is said to be alive but not runnable. The thread switches to this state because of reasons like wait method called or sleep method has been called on the running thread or thread might be waiting for some i/o resource so blocked. 5) Dead - When the thread finishes its execution i.e. the run() method execution completes, it is said to be in dead state. A dead state can not be started again. If a start() method is invoked on a dead thread a runtime exception will occur."},
				{"category":"Java","topic_id":"10","question":"What is use of synchronized keyword?","answer":"synchronized keyword can be applied to static/non-static methods or a block of code. Only one thread at a time can access synchronized methods and if there are multiple threads trying to access the same method then other threads have to wait for the execution of method by one thread. Synchronized keyword provides a lock on the object and thus prevents race condition."},
				{"category":"Java","topic_id":"10","question":"What is the difference when the synchronized keyword is applied to a static method or to a non static method?","answer":"When a synch non static method is called a lock is obtained on the object. When a synch static method is called a lock is obtained on the class and not on the object. The lock on the object and the lock on the class don't interfere with each other. It means, a thread accessing a synch non static method, then the other thread can access the synch static method at the same time but can't access the synch non static method. "},
				{"category":"Java","topic_id":"10","question":"What is the difference between yield() and sleep()?","answer":"yield() allows the current the thread to release its lock from the object and scheduler gives the lock of the object to the other thread with same priority. sleep() allows the thread to go to sleep state for x milliseconds. When a thread goes into sleep state it doesn't release the lock."},
				{"category":"Java","topic_id":"10","question":"What is the difference between wait() and sleep()?","answer":"1) wait() is a method of Object class. sleep() is a method of Object class.2) sleep() allows the thread to go to sleep state for x milliseconds. When a thread goes into sleep state it doesn't release the lock. wait() allows thread to release the lock and goes to suspended state. The thread is only active when a notify() or notifAll() method is called for the same object."},
				{"category":"Java","topic_id":"10","question":"What happens if a start method is not invoked and the run method is directly invoked?","answer":"If a thread has been instantiated but not started its is said to be in new state. Unless until a start() method is invoked on the instance of the thread, it will not said to be alive. If you do not call a start() method on the newly created thread instance thread is not considered to be alive. If the start() method is not invoked and the run() method is directly called on the Thread instance, the code inside the run() method will not run in a separate new thread but it will start running in the existing thread. "},
				{"category":"Java","topic_id":"10","question":"If code running is a thread creates a new thread what will be the initial priority of the newly created thread?","answer":"When a code running in a thread creates a new thread object , the priority of the new thread is set equal to the priority of the thread which has created it. "},
				{"category":"Java","topic_id":"10","question":"What are the daemon threads?","answer":"Daemon thread are service provider threads run in the background,these not used to run the application code generally.When all user threads(non-daemon threads) complete their execution the jvm exit the application whatever may be the state of the daemon threads. Jvm does not wait for the daemon threads to complete their execution if all user threads have completed their execution.To create Daemon thread set the daemon value of Thread using setDaemon(boolean value) method. By default all the threads created by user are user thread. To check whether a thread is a Daemon thread or a user thread use isDaemon() method."},
				{"category":"Java","topic_id":"10","question":"How many locks does an object have?","answer":"Each object has only one lock."},
				{"category":"Java","topic_id":"10","question":"Can a class have both Synchronized and non-synchronized methods?","answer":"Yes a class can have both synchronized and non-synchronized methods. "},
				{"category":"Java","topic_id":"10","question":"What is the advantage of new Lock interface over synchronized block in Java? ","answer":"The major advantage of lock interfaces on multi-threaded and concurrent programming is they provide two separate lock for reading and writing which enables you to write high performance data structure like concurrenthashmp and conditional blocking."},
				{"category":"Java","topic_id":"10","question":"What is volatile keyword in Java?","answer":"Volatile keyword in Java is used as an indicator to Thread that do not cache value of this variable and always read it from main memory. So if you want to share any variable in which operations read and write is atomic by implementation e.g. read and write in int or boolean variable you can make it volatile. with Java5 and change in Java Memory Model , Java guarantees visibility of changes made by one thread to another also as 'happens-before' which solves the problem of Memory writes that happen in one thread can 'leak through' and be seen by another thread."},
				{"category":"Java","topic_id":"10","question":"What is the difference between preemptive scheduling and time slicing?","answer":"Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then re-enters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors."},
				{"category":"Java","topic_id":"10","question":"What is deadlock?","answer":"When two threads are waiting for each other and can't proceed until the first thread obtains a lock on the other thread or vice versa, the program is said to be in a deadlock."},
				{"category":"Java","topic_id":"10","question":"How does multithreading take place on a computer with a single CPU?","answer":"The operating system's task scheduler allocates execution time to multiple tasks. By quickly switching between executing tasks, it creates the impression that tasks execute sequentially."},
				{"category":"Java","topic_id":"10","question":"Why would you use a synchronized block vs. synchronized method?","answer":"Synchronized blocks place locks for shorter periods than synchronized methods."},
				{"category":"Java","topic_id":"10","question":"Can a lock be acquired on a class? ","answer":"Yes, a lock can be acquired on a class. This lock is acquired on the class's Class object."},
				{"category":"Java","topic_id":"10","question":"Is there a separate stack for each thread in Java?","answer":"Yes. Every thread maintains its own separate stack, called Runtime Stack but they share the same memory. Elements of the stack are the method invocations,called activation records or stack frame. The activation record contains pertinent information about a method like local variables."}
	]
}